<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
</head>

<body>
	<h1>单例模式</h1>
	<i>单例模式是指一个类，只有一个实例。实现的思路是，创建实例时候加判断，如果有实例则返回，如果没有就new一个，并返回。</i>
	<ul>
		<li>js单例的好处
		<li>1.在全局中只生成一个变量，减少全局变量的污染，同时也很好的解决了命名冲突。</li>
		<li>2.只需新创建一次对象，减少对内存资源的占用。</li>
		<li>3.减少系统加载的时间，遇到bug更容易排查。</li>
	</ul>
	<h2>示例</h2>
	<ul>
		<li>登录</li>
		<li>购物车</li>
	</ul>
	<p>jquery只有一个$</p>






	<script type="text/javascript">
		class SingleObject {
			login() {
				console.log('longin...');
			}
		}

		SingleObject.getInstance = (function () {
			let instance;
			return function () {
				if (!instance) {
					instance = new SingleObject()
				}
				return instance;
			}
		})()


		let obj1 = SingleObject.getInstance();
		obj1.login();

		let obj2 = SingleObject.getInstance();
		obj2.login();

		console.log('obj1 === obj2', obj1 === obj2);

		console.log('-----------------');
		//不能new
		let obj3 = new SingleObject();
		console.log('obj1 === obj3', obj1 === obj3);


		////////////////////////////////////////////////////////////////

		var single = (function () {
			var unique;
			function Construct() {
				// ... 生成单例的构造函数的代码
				console.log('logout...');
			}
			unique = new Construct();
			return function () {
				return unique;
			}
		})();

		let a = single();
		let b = single();

		console.log(a === b)




		// function createClass(fn) {
		// 	var onlyClass = null;//这里是必要的，作为实例的容器
		// 	if (!onlyClass) {
		// 		onlyClass = fn.call(this);
		// 	}
		// 	return onlyClass
		// }



// //服务员 单例
// var waiterSingle = (function () { // 是一个立即执行函数，并将执行的结果赋值给waiterSingle
//     var waiter = null; // 实例存在这个变量里
//     function Waiter(id, name, salary) {
//         Employees.call(this, id, name, salary)
//     }
//     Waiter.prototype = Object.create(Employees.prototype);
//     Waiter.prototype.constructor= Waiter;
//     Waiter.prototype.work = function (arg) { // 重写原型上的方法
//         if (arg instanceof Array){ //数组的话，记录点菜
//             console.log('finish order dish $记录work');
//             return this;
//         } else { //上菜行为
//             console.log('finish serving a dish $记录work')
//         }
//     };
//     // cook调用的方法，返回菜单
//     Waiter.prototype.tellCookTheMenu = function () {
//         return this.menu;
//     };
//     // cook调用的方法，拿到做好的菜
//     Waiter.prototype.serving = function () {
//         this.work();// 上菜行为
//         this.customer.eat();
//     };
// 
//     // 从顾客order方法，拿到点的菜
//     Waiter.prototype.getMenu = function (arg) {
//         this.customer = arg;
//         this.menu = arg.dish;
//         console.log('waiter get the menu', this.menu);
//         return this;
//     };
// 
//     return {
//         name: 'waiter',
//         getWaiterInstance: function (...arg) {
//             if (!waiter) {  // 判断如果waiter里没有，则new，并赋值给waiter
//                 waiter = new Waiter(...arg)
//             }
//             return waiter;
//         }
//     }
// })();
// var waiter = waiterSingle.getWaiterInstance(2, 'Lucy', 5000);




	</script>
</body>

</html>